# A0124995R
###### ./src/main/java/cs2103/v15_1j/jolt/command/AddCommand.java
``` java
	@Override
	public UIFeedback undo(ControllerStates conStates) {
		conStates.masterList.remove(taskEvent);

		if (conStates.storage.save(conStates.masterList)) {
			conStates.redoCommandHistory.push(this);
			return new DeleteFeedback(taskEvent);
		} else {
			// If conStates.storage fails to save list
			// add task/event back to conStates.masterList and displayList
			conStates.masterList.add(taskEvent);
			conStates.undoCommandHistory.push(this);
			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}

	@Override
	public UIFeedback execute(ControllerStates conStates) {
		conStates.masterList.add(taskEvent);

		if (conStates.storage.save(conStates.masterList)) {
			conStates.undoCommandHistory.push(this);
			return new AddFeedback(taskEvent);
		} else {
			// If conStates.storage fails to save list
			// remove task
			conStates.redoCommandHistory.push(this);
			conStates.masterList.remove(taskEvent);
			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}

	public TaskEvent getTaskEvent() {
		return taskEvent;
	}

}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/AliasAddCommand.java
``` java
	@Override
	public UIFeedback undo(ControllerStates conStates) {
		conStates.config.aliases.remove(alias, keyword);

		if (conStates.storage.saveConfig(conStates.config)) {
			conStates.redoCommandHistory.push(this);
			return new AliasDeleteFeedback(alias);
		} else {
			// If conStates.storage fails to save list
			// add alias back to config
			conStates.config.aliases.put(alias, keyword);
			conStates.undoCommandHistory.push(this);
			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}

	@Override
	public UIFeedback execute(ControllerStates conStates) {
		conStates.config.aliases.put(alias, keyword);

		if (conStates.storage.saveConfig(conStates.config)) {
			conStates.undoCommandHistory.push(this);
			return new AliasAddFeedback(alias, keywordString);
		} else {
			// If conStates.storage fails to save config
			// remove alias
			conStates.redoCommandHistory.push(this);
			conStates.config.aliases.remove(alias, keyword);
			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/AliasDeleteCommand.java
``` java
	private Integer keyword;
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/AliasDeleteCommand.java
``` java
	@Override
	public UIFeedback undo(ControllerStates conStates) {
		conStates.config.aliases.put(alias, keyword);

		if (conStates.storage.saveConfig(conStates.config)) {
			conStates.redoCommandHistory.push(this);
			return new AliasAddFeedback(alias);
		} else {
			// If conStates.storage fails to save list
			// add alias back to config
			conStates.config.aliases.remove(alias, keyword);
			conStates.undoCommandHistory.push(this);
			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}

	@Override
	public UIFeedback execute(ControllerStates conStates) {
		keyword = conStates.config.aliases.remove(alias);
		if (keyword == null) {
			return new FailureFeedback("Alias specified for deletion does not exist");
		}
		if (conStates.storage.saveConfig(conStates.config)) {
			conStates.undoCommandHistory.push(this);
			return new AliasDeleteFeedback(alias);
		} else {
			// If conStates.storage fails to save config
			// remove alias
			conStates.redoCommandHistory.push(this);
			conStates.config.aliases.put(alias, keyword);
			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/AliasListCommand.java
``` java
	@Override
	public UIFeedback execute(ControllerStates conStates) {
		Map<String, Integer> mappings = conStates.config.aliases;
		Map<String, String> feedbackList = new HashMap<String, String>();

		for (Entry<String, Integer> entry : mappings.entrySet()) {
			feedbackList.put(entry.getKey(), conStates.parser.getKeywordString(entry.getValue()));
		}
		return new AliasListFeedback(feedbackList);
	}

}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/ChangeCommand.java
``` java
	@Override
	public UIFeedback undo(ControllerStates conStates) {
		TaskEvent temp = conStates.masterList.remove(actual);
		conStates.masterList.add(backup);

		if (conStates.storage.save(conStates.masterList)) {
			conStates.redoCommandHistory.push(this);
			return new ChangeFeedback("Task/Event successfully changed back!");
		} else {
			conStates.masterList.remove(backup);
			conStates.masterList.add(temp);
			conStates.undoCommandHistory.push(this);
			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}

	@Override
	public UIFeedback execute(ControllerStates conStates) {
		try {
			DeadlineTask deadlineTask = null;
			FloatingTask floatingTask = null;
            Event event = null;
			actual = conStates.displayList.getTaskEvent(taskNum-1, prefix);

			if (actual instanceof FloatingTask) {
				floatingTask = (FloatingTask) actual;
				backup = new FloatingTask((FloatingTask) actual);
			} else if (actual instanceof DeadlineTask) {
				deadlineTask = (DeadlineTask) actual;
				backup = new DeadlineTask((DeadlineTask) actual);
			} else {
				event = (Event) actual;
				backup = new Event((Event) actual);
			}
            
            if (newName != null) {
            	actual.setName(newName);
            }
            if (newStartDate != null) {
            	if (actual instanceof DeadlineTask) {
            		deadlineTask.setDate(newStartDate);
            	} else if (actual instanceof FloatingTask) {
            		conStates.masterList.remove(actual);
            		actual = new DeadlineTask(floatingTask, newStartDate.atTime(LocalTime.MAX));
            		deadlineTask = (DeadlineTask) actual;
            		conStates.masterList.add(actual);
            	} else if (actual instanceof Event) {
            		event.setStartDate(newStartDate);
            	} 
            }
            if (newStartTime != null) {
            	if (actual instanceof DeadlineTask) {
            		deadlineTask.setTime(newStartTime);
            	} else if (actual instanceof FloatingTask) {
            		conStates.masterList.remove(actual);
            		actual = new DeadlineTask(floatingTask, LocalDate.now().atTime(newStartTime));
            		deadlineTask = (DeadlineTask) actual;
            		conStates.masterList.add(actual);
            	} else if (actual instanceof Event) {
            		event.setStartTime(newStartTime);
            	}
            }
            if (newEndDate != null) {
            	if (actual instanceof Event) {
            		event.setEndDate(newEndDate);
            	}
            }
            if (newEndTime != null) {
            	if (actual instanceof Event) {
            		event.setEndTime(newEndTime);
            	}
            }
            
            if (actual instanceof Event) {
            	if (event.getEndDateTime().isBefore(event.getStartDateTime())) {
            		conStates.masterList.remove(actual);
            		conStates.masterList.add(backup);
            		return new FailureFeedback("Can't have the end datetime of an event before the start datetime!");
            	}
            }
            
            conStates.masterList.sort();
            
            if (conStates.storage.save(conStates.masterList)) {
            	conStates.undoCommandHistory.push(this);
                return new ChangeFeedback("Task/Event successfully changed!");
            } else {
            	conStates.redoCommandHistory.push(this);
            	conStates.masterList.remove(actual);
            	conStates.masterList.add(backup);
                return new FailureFeedback("Some error has occured. Please try again.");
            }
		} catch (IndexOutOfBoundsException e) {
			return new FailureFeedback("There is no item numbered " + this.prefix + this.taskNum);
		}
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/DeleteCommand.java
``` java
	@Override
	public UIFeedback undo(ControllerStates conStates) {
		// Add task/event back at former position
		conStates.masterList.add(backup);

		if (conStates.storage.save(conStates.masterList)) {
			conStates.redoCommandHistory.push(this);
			return new AddFeedback(backup);
		} else {
			// failed, remove task
			conStates.undoCommandHistory.push(this);
			conStates.masterList.remove(backup);

			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}

	@Override
	public UIFeedback execute(ControllerStates conStates) {
		try {
			TaskEvent displayTemp = conStates.displayList.getTaskEvent(taskNum - 1, prefix);
			backup = conStates.masterList.remove(displayTemp);

			if (!conStates.searchResultsList.isEmpty()) {
				conStates.searchResultsList.remove(backup);
			}

			if (conStates.storage.save(conStates.masterList)) {
				conStates.undoCommandHistory.push(this);
				return new DeleteFeedback(backup);
			} else {
				// failed to delete, add the item back in the old position
				conStates.redoCommandHistory.push(this);
				conStates.masterList.add(backup);

				return new FailureFeedback("Some error has occured. Please try again.");
			}
		} catch (IndexOutOfBoundsException e) {
			return new FailureFeedback("There is no item numbered " + this.prefix + this.taskNum);
		}
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/MarkDoneCommand.java
``` java
	@Override
	public UIFeedback undo(ControllerStates conStates) {
		backup.setCompleted(false);
		if (conStates.storage.save(conStates.masterList)) {
			conStates.redoCommandHistory.push(this);
			return new UnmarkFeedback(backup);
		} else {
			backup.setCompleted(true);
			conStates.undoCommandHistory.push(this);
			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}

	@Override
	public UIFeedback execute(ControllerStates conStates) {
		try {
			backup = conStates.displayList.getTaskEvent(taskNum - 1, prefix);
			backup.setCompleted(true);
			if (conStates.storage.save(conStates.masterList)) {
				conStates.undoCommandHistory.push(this);
				return new MarkFeedback(backup);
			} else {
				// failed to save, add the item back
				conStates.redoCommandHistory.push(this);
				backup.setCompleted(false);
				return new FailureFeedback("Some error has occured. Please try again.");
			}
		} catch (IndexOutOfBoundsException e) {
			return new FailureFeedback("There is no item numbered " + this.prefix + this.taskNum);
		}
	}

}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/RedoCommand.java
``` java
	@Override
	public UIFeedback execute(ControllerStates conStates) {
		if (conStates.redoCommandHistory.empty()) {
			return new FailureFeedback("Nothing to redo!");
		}
		UndoableCommand topCommand = conStates.redoCommandHistory.pop();
		UIFeedback feedback = topCommand.execute(conStates);
		return feedback;
	}

}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/SaveLocationCommand.java
``` java
    @Override
    public UIFeedback execute(ControllerStates conStates) {
    	String backup = conStates.config.savePath;
    	File file = null;
    	
    	if (savePath.contains(" ")) {
    		return new FailureFeedback("Invalid file path specified!");
    	}
    	
    	try {
    		file = new File(savePath);
            if (!file.exists()) {
            	File parent = file.getParentFile();
            	if (parent != null && !parent.exists()) {
            		parent.mkdirs();
            	}
            	file.createNewFile();
            }
    	} catch (Exception e) {
    		return new FailureFeedback("Invalid file path specified!");
    	}
    	
    	conStates.config.savePath = savePath;
    	conStates.storage.setSaveFile(savePath);
    	conStates.storage.save(conStates.masterList);
    	
    	if (conStates.storage.saveConfig(conStates.config)) {
        	return new SaveLocationFeedback(savePath);
        } else {
            // If conStates.storage fails to save config
        	// set savePath back to previous value
            conStates.config.savePath = backup;
            conStates.storage.setSaveFile(backup);
            return new FailureFeedback("Some error has occured. Please try again.");
        }
    }
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/SearchCommand.java
``` java
public class SearchCommand implements Command {

	private List<Filter> filters;

	public SearchCommand(List<Filter> filters) {
		this.filters = filters;
	}

	public List<Filter> getFilters() {
		return filters;
	}

	@Override
	public UIFeedback execute(ControllerStates conStates) {
		try {
			DataLists searchResults = conStates.searcher.search(filters, conStates.masterList);
			conStates.searchResultsList.copy(searchResults);
			return new SearchFeedback(filters);
		} catch (Exception e) {
			return new FailureFeedback("Some error has occurred. Please try again.");
		}
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/ShiftCommand.java
``` java
	@Override
	public UIFeedback undo(ControllerStates conStates) {
		TaskEvent temp = conStates.masterList.remove(actual);
		conStates.masterList.add(backup);

		if (conStates.storage.save(conStates.masterList)) {
			conStates.redoCommandHistory.push(this);
			return new ShiftFeedback(backup.getName(), backup.getStartDateTime(), backup.getEndDateTime());
		} else {
			conStates.masterList.remove(backup);
			conStates.masterList.add(temp);
			conStates.undoCommandHistory.push(this);
			return new FailureFeedback("Some error has occured. Please try again.");
		}
	}

    @Override
    public UIFeedback execute(ControllerStates conStates) {
        try {
        	actual = conStates.displayList.getTaskEvent(taskNum-1, prefix);
            Event tempEvent = null;
        	if (actual instanceof FloatingTask || actual instanceof DeadlineTask) {
        		return new FailureFeedback("Invalid syntax for shifting " + prefix + taskNum);	
			} else {
				tempEvent = (Event) actual;
				backup = new Event(tempEvent);
				LocalDateTime currentStartDateTime = tempEvent.getStartDateTime();
				LocalDateTime currentEndDateTime = tempEvent.getEndDateTime();

				LocalDateTime newStartDateTime = currentStartDateTime;
				if (newDate != null) {
					newStartDateTime = newStartDateTime.with(newDate);
				}
				if (newTime != null) {
					newStartDateTime = newStartDateTime.with(newTime);
				}

				long diffInSeconds = Duration.between(currentStartDateTime, currentEndDateTime).getSeconds();
				LocalDateTime newEndDateTime = newStartDateTime.plusSeconds(diffInSeconds);

				tempEvent.setStartDateTime(newStartDateTime);
				tempEvent.setEndDateTime(newEndDateTime);

				if (conStates.storage.save(conStates.masterList)) {
					conStates.undoCommandHistory.push(this);
					return new ShiftFeedback(tempEvent.getName(), newStartDateTime, newEndDateTime);
				} else {
					conStates.redoCommandHistory.push(this);
					conStates.masterList.remove(actual);
					conStates.masterList.add(backup);
					return new FailureFeedback("Some error has occured. Please try again.");
				}
			}
		} catch (IndexOutOfBoundsException e) {
			return new FailureFeedback("There is no item numbered " + this.prefix + this.taskNum);
		}
	}

}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/ShowHideOverdueCommand.java
``` java
	@Override
	public UIFeedback execute(ControllerStates conStates) {
		return new ShowHideOverdueFeedback(willShow);
	}

}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/UndoCommand.java
``` java
	@Override
	public UIFeedback execute(ControllerStates conStates) {
		if (conStates.undoCommandHistory.empty()) {
			return new FailureFeedback("Nothing to undo!");
		}
		UndoableCommand topCommand = conStates.undoCommandHistory.pop();
		UIFeedback feedback = topCommand.undo(conStates);
		return feedback;
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/command/UnmarkCommand.java
``` java
    @Override
    public UIFeedback undo(ControllerStates conStates) {
        backup.setCompleted(true);
        if (conStates.storage.save(conStates.masterList)) {
        	conStates.redoCommandHistory.push(this);
        	return new MarkFeedback(backup);
        } else {
        	backup.setCompleted(false);
        	conStates.undoCommandHistory.push(this);
        	return new FailureFeedback("Some error has occured. Please try again.");
        }
    }

    @Override
    public UIFeedback execute(ControllerStates conStates) {
        try {
            backup = conStates.displayList.getTaskEvent(taskNum-1, prefix);
            backup.setCompleted(false);
            if (conStates.storage.save(conStates.masterList)) {
            	conStates.undoCommandHistory.push(this);
                return new UnmarkFeedback(backup);
            } else {
            	conStates.redoCommandHistory.push(this);
                backup.setCompleted(true);
                return new FailureFeedback("Some error has occured. Please try again.");
            }
        } catch (IndexOutOfBoundsException e) {
            return new FailureFeedback(
                    "There is no item numbered " + this.prefix + this.taskNum);
        }
    }
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/controller/Configuration.java
``` java
import java.util.HashMap;
import java.util.Map;

public class Configuration {
	public String savePath = "save_data.json"; // default configurations
	public Map<String, Integer> aliases = new HashMap<>();

	@Override
	public boolean equals(Object t) {
		if (t == null || !(t instanceof Configuration)) {
			return false;
		}
		Configuration other = (Configuration) t;
		return this.savePath.equals(other.savePath) && this.aliases.equals(other.aliases);
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/controller/ControllerStates.java
``` java
	public void resetRedoHistory() {
		redoCommandHistory = new Stack<UndoableCommand>();
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/model/DataLists.java
``` java
	public TaskEvent getTaskEvent(int num, char prefix) {
		TaskEvent result;
		switch (prefix) {
		case 'f':
			result = floatingTasksList.get(num);
			break;
		case 'd':
			result = deadlineTasksList.get(num);
			break;
		case 'e':
			result = eventsList.get(num);
			break;
		default:
			assert false; // shouldn't happen
			result = null;
			break;
		}
		return result;
	}

	public TaskEvent remove(int num, char prefix) {
		TaskEvent result;
		switch (prefix) {
		case 'f':
			result = floatingTasksList.remove(num);
			break;
		case 'd':
			result = deadlineTasksList.remove(num);
			break;
		case 'e':
			result = eventsList.remove(num);
			break;
		default:
			assert false; // shouldn't happen
			result = null;
			break;
		}
		return result;
	}

```
###### ./src/main/java/cs2103/v15_1j/jolt/model/DeadlineTask.java
``` java
	public DeadlineTask(DeadlineTask other) {
		this(other.getName(), other.getDateTime());
	}
```
###### ./src/main/java/cs2103/v15_1j/jolt/model/DeadlineTask.java
``` java
	@Override
	public boolean equals(Object t) {
		if (t == null || !(t instanceof DeadlineTask)) {
			return false;
		}
		DeadlineTask other = (DeadlineTask) t;
		return this.getName().equals(other.getName()) && this.getDateTime().equals(other.getDateTime());
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/model/Event.java
``` java
	public Event(Event e) {
		this(e.getName(), e.getStartDateTime(), e.getEndDateTime());
	}

```
###### ./src/main/java/cs2103/v15_1j/jolt/model/FloatingTask.java
``` java
	public FloatingTask(FloatingTask other) {
		this(other.getName());
	}

```
###### ./src/main/java/cs2103/v15_1j/jolt/model/FloatingTask.java
``` java
	@Override
	public boolean equals(Object t) {
		if (t == null || !(t instanceof FloatingTask)) {
			return false;
		}
		FloatingTask other = (FloatingTask) t;
		return this.getName().equals(other.getName());
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/searcher/DateTimeFilter.java
``` java
import java.time.LocalDateTime;

import cs2103.v15_1j.jolt.model.DeadlineTask;
import cs2103.v15_1j.jolt.model.Event;
import cs2103.v15_1j.jolt.model.FloatingTask;
import cs2103.v15_1j.jolt.model.TaskEvent;

public class DateTimeFilter implements Filter {

	LocalDateTime start;
	LocalDateTime end;

	public DateTimeFilter(LocalDateTime start, LocalDateTime end) {
		this.start = start;
		this.end = end;
	}

	public LocalDateTime getStart() {
		return start;
	}

	public LocalDateTime getEnd() {
		return end;
	}

	@Override
	public boolean check(TaskEvent taskEvent) {
		if (taskEvent instanceof FloatingTask) {
			return false; // floating tasks have no datetime
		} else if (taskEvent instanceof DeadlineTask) {
			DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
			LocalDateTime deadline = deadlineTask.getDateTime();
			if ((start.compareTo(deadline) <= 0) && (end.compareTo(deadline) >= 0)) {
				return true;
			} else
				return false;
		} else {
			Event event = (Event) taskEvent;
			LocalDateTime eventStart = event.getStartDateTime();
			LocalDateTime eventEnd = event.getEndDateTime();
			if ((start.compareTo(eventStart) <= 0) && (end.compareTo(eventEnd) >= 0)) {
				return true;
			}
			return false;
		}
	}

}
```
###### ./src/main/java/cs2103/v15_1j/jolt/searcher/JoltSearcher.java
``` java

import java.util.List;

import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.model.DeadlineTask;
import cs2103.v15_1j.jolt.model.Event;
import cs2103.v15_1j.jolt.model.FloatingTask;

public class JoltSearcher implements Searcher {
	@Override
	public DataLists search(List<Filter> filters, DataLists masterLists) {
		DataLists resultsList = new DataLists(); // Result to be returned

		List<DeadlineTask> masterDeadlineTasksList = masterLists.getDeadlineTasksList();
		List<FloatingTask> masterFloatingTasksList = masterLists.getFloatingTasksList();
		List<Event> masterEventsList = masterLists.getEventsList();

		List<DeadlineTask> searchResultsDeadlineTasksList = resultsList.getDeadlineTasksList();
		getDeadlineTasksSearchResults(filters, masterDeadlineTasksList, searchResultsDeadlineTasksList);

		List<FloatingTask> searchResultsFloatingTasksList = resultsList.getFloatingTasksList();
		getFloatingTasksSearchResult(filters, masterFloatingTasksList, searchResultsFloatingTasksList);

		List<Event> searchResultsEventsList = resultsList.getEventsList();
		getEventsSearchResult(filters, masterEventsList, searchResultsEventsList);

		return resultsList;
	}

	private void getEventsSearchResult(List<Filter> filters, List<Event> masterEventsList,
			List<Event> resultsEventsList) {
		for (Event event : masterEventsList) {
			if (checkFilters(event, filters)) {
				resultsEventsList.add(event);
			}
		}
	}

	private void getFloatingTasksSearchResult(List<Filter> filters, List<FloatingTask> masterFloatingTasksList,
			List<FloatingTask> resultsFloatingTasksList) {
		for (FloatingTask floatingTask : masterFloatingTasksList) {
			if (checkFilters(floatingTask, filters)) {
				resultsFloatingTasksList.add(floatingTask);
			}
		}
	}

	private void getDeadlineTasksSearchResults(List<Filter> filters, List<DeadlineTask> masterDeadlineTasksList,
			List<DeadlineTask> resultsDeadlineTasksList) {
		for (DeadlineTask task : masterDeadlineTasksList) {
			if (checkFilters(task, filters)) {
				resultsDeadlineTasksList.add(task);
			}
		}
	}

	private boolean checkFilters(DeadlineTask deadlineTask, List<Filter> filters) {
		for (Filter filter : filters) {
			if (!filter.check(deadlineTask))
				return false;
		}
		return true;
	}

	private boolean checkFilters(FloatingTask floatingTask, List<Filter> filters) {
		for (Filter filter : filters) {
			if (!filter.check(floatingTask))
				return false;
		}
		return true;
	}

	private boolean checkFilters(Event event, List<Filter> filters) {
		for (Filter filter : filters) {
			if (!filter.check(event))
				return false;
		}
		return true;
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/searcher/KeywordFilter.java
``` java

import java.util.Arrays;
import java.util.List;

import cs2103.v15_1j.jolt.model.TaskEvent;

public class KeywordFilter implements Filter {

	List<String> keywords;

	public KeywordFilter(List<String> keywords) {
		this.keywords = keywords;
	}

	public List<String> getKeywords() {
		return keywords;
	}

	@Override
	public boolean check(TaskEvent taskEvent) {
		if (keywords.size() == 1 && keywords.get(0).length() == 1) { // Single
																		// char
			char keyword = keywords.get(0).charAt(0);
			if (Character.toLowerCase(keyword) == Character.toLowerCase(taskEvent.getName().charAt(0))) {
				return true;
			}
		}
		List<String> wordsInName = Arrays.asList(taskEvent.getName().split(" "));
		for (String word : wordsInName) {
			for (String keyword : keywords) {
				if (word.equalsIgnoreCase(keyword)) {
					return true;
				}
			}
		}
		return false;
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/searcher/TimeFilter.java
``` java

import java.time.LocalTime;

import cs2103.v15_1j.jolt.model.DeadlineTask;
import cs2103.v15_1j.jolt.model.Event;
import cs2103.v15_1j.jolt.model.FloatingTask;
import cs2103.v15_1j.jolt.model.TaskEvent;

public class TimeFilter implements Filter {

	LocalTime start;
	LocalTime end;

	public TimeFilter(LocalTime start, LocalTime end) {
		this.start = start;
		this.end = end;
	}

	public LocalTime getStart() {
		return start;
	}

	public LocalTime getEnd() {
		return end;
	}

	@Override
	public boolean check(TaskEvent taskEvent) {
		if (taskEvent instanceof FloatingTask) {
			return false;
		} else if (taskEvent instanceof DeadlineTask) {
			DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
			LocalTime deadline = deadlineTask.getDateTime().toLocalTime();
			if ((start.compareTo(deadline) <= 0) && (end.compareTo(deadline) >= 0)) {
				return true;
			} else
				return false;
		} else {
			Event event = (Event) taskEvent;
			LocalTime startTime = event.getStartDateTime().toLocalTime();
			LocalTime endTime = event.getEndDateTime().toLocalTime();
			if ((start.compareTo(startTime) <= 0) && (end.compareTo(endTime) >= 0)) {
				return true;
			}
			return false;
		}
	}

}
```
###### ./src/main/java/cs2103/v15_1j/jolt/storage/JoltStorage.java
``` java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;

import cs2103.v15_1j.jolt.controller.Configuration;
import cs2103.v15_1j.jolt.model.DataLists;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.StringProperty;

import java.lang.reflect.Type;

public class JoltStorage implements Storage {
	private File saveFile;
	private File configFile;
	private Type dataListsType;
	private Type configType;
	private GsonBuilder builder;
	private Gson gson;

	public JoltStorage() {
		dataListsType = new TypeToken<DataLists>() {}.getType();
		configType = new TypeToken<Configuration>() {}.getType();
		builder = new GsonBuilder().setPrettyPrinting();
		builder.registerTypeAdapter(ObjectProperty.class, new PropertyTypeAdapter());
		builder.registerTypeAdapter(StringProperty.class, new PropertyTypeAdapter());
		builder.registerTypeAdapter(IntegerProperty.class, new PropertyTypeAdapter());
		builder.registerTypeAdapter(BooleanProperty.class, new PropertyTypeAdapter());
		gson = builder.create();
	}

	// Sets save file to be used for saving/loading
	public void setSaveFile(String saveFileName) {
		saveFile = new File(saveFileName);
	}

	// Return save file
	public File getSaveFile() {
		return saveFile;
	}

	@Override
	public DataLists load() {
		BufferedReader reader = null;
		try {
			// Reads data from file
			reader = new BufferedReader(new FileReader(saveFile));
			// Converts read data back into Java types
			return gson.fromJson(reader, dataListsType);
		} catch (Exception e) {
			return new DataLists();
		} finally {
			try {
				if (reader != null) {
					reader.close();
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

	@Override
	public boolean save(DataLists list) {
		String dataListsJSON = gson.toJson(list, dataListsType);

		return writeJSONToFile(dataListsJSON, saveFile);
	}

    private boolean writeJSONToFile(String jsonString, File file) {
        try {
            // Create new file if it doesn't exist
            if (!file.exists()) {
            	File parent = file.getParentFile();
            	if (parent != null && !parent.exists()) {
            		parent.mkdirs();
            	}
            	file.createNewFile();
            }
            // Write the JSON to saved file
            BufferedWriter writer = new BufferedWriter(
                    new FileWriter(file));

			writer.write(jsonString);
			writer.close();
		} catch (IOException e) {
			return false;
		}

		return true;
	}

	@Override
	public Configuration loadConfig() {
		BufferedReader reader = null;
		try {
			// Reads data from file
			reader = new BufferedReader(new FileReader(configFile));
			// Converts read data back into Java types
			return gson.fromJson(reader, configType);
		} catch (FileNotFoundException e) {
			Configuration newConfig = new Configuration();
			saveConfig(newConfig); // Generate new config file and save if it
									// doesn't exist
			return newConfig;
		} catch (Exception e) {
			return null;
		} finally {
			try {
				if (reader != null) {
					reader.close();
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

	@Override
	public boolean saveConfig(Configuration config) {
		String configJSON = gson.toJson(config, configType);

		return writeJSONToFile(configJSON, configFile);
	}

	@Override
	public void setConfigFile(String configFileName) {
		configFile = new File(configFileName);
	}

	public File getConfigFile() {
		return configFile;
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/uifeedback/AliasListFeedback.java
``` java

import java.util.Map;

import cs2103.v15_1j.jolt.ui.MainViewController;

public class AliasListFeedback implements UIFeedback {
	Map<String, String> aliasList;

	public AliasListFeedback(Map<String, String> aliasList) {
		this.aliasList = aliasList;
	}

	public Map<String, String> getFeedbackList() {
		return aliasList;
	}

	@Override
	public void execute(MainViewController con) {
		con.showAliases(aliasList);
	}

	@Override
	public boolean equals(Object t) {
		if (t == null || !(t instanceof AliasListFeedback)) {
			return false;
		}
		AliasListFeedback other = (AliasListFeedback) t;
		return this.aliasList.equals(other.aliasList);
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/uifeedback/DeleteFeedback.java
``` java

	@Override
	public void execute(MainViewController con) {
		con.showNotification("\"" + taskEvent.getName() + "\" has been deleted.");
	}

	@Override
	public boolean equals(Object t) {
		if (t == null || !(t instanceof DeleteFeedback)) {
			return false;
		}
		DeleteFeedback other = (DeleteFeedback) t;
		return this.taskEvent.equals(other.taskEvent);
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/uifeedback/FailureFeedback.java
``` java

	@Override
	public boolean equals(Object t) {
		if (t == null || !(t instanceof FailureFeedback)) {
			return false;
		}
		FailureFeedback other = (FailureFeedback) t;
		return this.message.equals(other.message);
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/uifeedback/MarkFeedback.java
``` java

	@Override
	public void execute(MainViewController con) {
		con.showNotification("\"" + task.getName() + "\" has been completed.");
	}

	@Override
	public boolean equals(Object t) {
		if (t == null || !(t instanceof MarkFeedback)) {
			return false;
		}
		MarkFeedback other = (MarkFeedback) t;
		return this.task.equals(other.task);
	}
}
```
###### ./src/main/java/cs2103/v15_1j/jolt/uifeedback/ShiftFeedback.java
``` java

import java.time.LocalDateTime;

import cs2103.v15_1j.jolt.ui.MainViewController;

public class ShiftFeedback implements UIFeedback {
	private String name;
	private LocalDateTime startDateTime;
	private LocalDateTime endDateTime;

	public ShiftFeedback(String name, LocalDateTime startDateTime, LocalDateTime endDateTime) {
		this.name = name;
		this.startDateTime = startDateTime;
		this.endDateTime = endDateTime;
	}

	@Override
	public void execute(MainViewController con) {
		con.showNotification(
				"\"" + name + "\" is now from: " + startDateTime.toString() + " to " + endDateTime.toString());
	}

	@Override
	public boolean equals(Object t) {
		if (t == null || !(t instanceof ShiftFeedback)) {
			return false;
		}
		ShiftFeedback other = (ShiftFeedback) t;
		return this.name.equals(other.name) && this.startDateTime.equals(other.startDateTime)
				&& this.endDateTime.equals(other.endDateTime);
	}
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/AddCommandTest.java
``` java

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Stack;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.AddCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.model.DeadlineTask;
import cs2103.v15_1j.jolt.model.Event;
import cs2103.v15_1j.jolt.uifeedback.AddFeedback;
import cs2103.v15_1j.jolt.uifeedback.DeleteFeedback;
import cs2103.v15_1j.jolt.uifeedback.FailureFeedback;
import cs2103.v15_1j.jolt.uifeedback.UIFeedback;

public class AddCommandTest {
    
    ControllerStates conStates;
    DataLists masterList;
    DataLists displayList;
    StubStorage storage;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;

    @Before
    public void setUp() throws Exception {
        masterList = new DataLists();
        displayList = new DataLists();
        storage = new StubStorage();
        undoCommandHistory = new Stack<UndoableCommand>();
        redoCommandHistory = new Stack<UndoableCommand>();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = displayList;
        conStates.storage = storage;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;
    }

    @Test
    public void testAddFloatingTask() {
        AddCommand command =
                new AddCommand("Buy oranges");
        UIFeedback result = command.execute(conStates);
        assertTrue(result instanceof AddFeedback);
        AddFeedback addFeedback = (AddFeedback) result;
        assertEquals(command.getTaskEvent(), addFeedback.getTaskEvent());
        assertEquals(1, masterList.getFloatingTasksList().size());
        assertEquals("Buy oranges", masterList.getFloatingTasksList().get(0).getName());
    }

    @Test
    public void testAddDeadlineTask() {
        AddCommand command =
                new AddCommand("Buy oranges",
                                   LocalDateTime.of(2016, 4, 30, 12, 00));
        UIFeedback result = command.execute(conStates);
        assertTrue(result instanceof AddFeedback);
        AddFeedback addFeedback = (AddFeedback) result;
        assertEquals(command.getTaskEvent(), addFeedback.getTaskEvent());
        assertEquals(1, masterList.getDeadlineTasksList().size());
        assertEquals("Buy oranges", masterList.getDeadlineTasksList().get(0).getName());
        assertEquals(LocalDateTime.of(2016, 4, 30, 12, 00),
                ((DeadlineTask)masterList.getDeadlineTasksList().get(0)).getDateTime());
    }
    
    @Test
    public void testAddEvent() {
    	LocalDateTime startDateTime = LocalDateTime.of(2016, 4, 30, 12, 00);
    	LocalDateTime endDateTime = LocalDateTime.of(2016, 4, 30, 16,00);
        AddCommand command =
                new AddCommand("Meeting with boss", startDateTime, endDateTime);
        UIFeedback result = command.execute(conStates);
        
        assertTrue(result instanceof AddFeedback);
        AddFeedback addFeedback = (AddFeedback) result;
        assertEquals(command.getTaskEvent(), addFeedback.getTaskEvent());
        assertEquals(1, masterList.getEventsList().size());
        
        assertEquals("Meeting with boss", masterList.getEventsList().get(0).getName());
        Event event = (Event) masterList.getEventsList().get(0);
        
        assertEquals(startDateTime, event.getStartDateTime());
        assertEquals(endDateTime, event.getEndDateTime());
    }

    @Test
    public void testStorageError() {
        AddCommand command =
                new AddCommand("Storage error",
                                   LocalDateTime.of(2016, 4, 30, 12, 00));
        // Make sure storage fails
        storage.setStorageError();
        UIFeedback result = command.execute(conStates);
        assertTrue(result instanceof FailureFeedback);
        FailureFeedback feedback = (FailureFeedback) result;
        assertEquals("Some error has occured. Please try again.",
                feedback.getMessage());
        assertEquals(true, masterList.getDeadlineTasksList().isEmpty());
    }

    @Test
    public void testUndo() {
    	AddCommand addCommand = new AddCommand("buy eggs", LocalDateTime.now());
		DeleteFeedback expectedFeedback = new DeleteFeedback(addCommand.getTaskEvent());
		addCommand.execute(conStates);
		assertEquals(masterList.size(), 1);
		
		UIFeedback actualFeedback = addCommand.undo(conStates);
		assertEquals(masterList.size(), 0);
		assertEquals(expectedFeedback, actualFeedback);
    }

```
###### ./src/test/java/cs2103/v15_1j/jolt/command/AliasAddCommandTest.java
``` java

import static org.junit.Assert.*;

import java.util.Stack;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.AliasAddCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.controller.Configuration;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.uifeedback.AliasAddFeedback;
import cs2103.v15_1j.jolt.uifeedback.AliasDeleteFeedback;
import cs2103.v15_1j.jolt.uifeedback.UIFeedback;

public class AliasAddCommandTest {
    ControllerStates conStates;
    DataLists masterList;
    DataLists displayList;
    StubStorage storage;
    Configuration config;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;

    @Before
    public void setUp() throws Exception {
        masterList = new DataLists();
        displayList = new DataLists();
        storage = new StubStorage();
        config = new Configuration();
        undoCommandHistory = new Stack<UndoableCommand>();
        redoCommandHistory = new Stack<UndoableCommand>();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = displayList;
        conStates.storage = storage;
        conStates.config = config;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;
    }
    
    @Test
    public void testUndo() {
		String alias = "be";
		int keyword = 1;
		String keywordString = "buy eggs";
		
		assertEquals(0, conStates.config.aliases.size());
		AliasAddCommand aliasAdd = new AliasAddCommand(alias, keyword, keywordString);
		aliasAdd.execute(conStates);
		assertEquals(1, conStates.config.aliases.size());
		
		UIFeedback feedback = aliasAdd.undo(conStates);
		assertTrue(feedback instanceof AliasDeleteFeedback);
		assertEquals(0, conStates.config.aliases.size());
    }

	@Test
	public void testExecute() {
		String alias = "be";
		int keyword = 1;
		String keywordString = "buy eggs";
		
		assertEquals(0, conStates.config.aliases.size());
		AliasAddCommand aliasAdd = new AliasAddCommand(alias, keyword, keywordString);
		
		UIFeedback feedback = aliasAdd.execute(conStates);
		assertTrue(feedback instanceof AliasAddFeedback);
		assertEquals(1, conStates.config.aliases.size());
	}
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/AliasDeleteCommandTest.java
``` java

import static org.junit.Assert.*;

import java.util.Stack;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.AliasAddCommand;
import cs2103.v15_1j.jolt.command.AliasDeleteCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.controller.Configuration;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.uifeedback.AliasAddFeedback;
import cs2103.v15_1j.jolt.uifeedback.AliasDeleteFeedback;
import cs2103.v15_1j.jolt.uifeedback.UIFeedback;

public class AliasDeleteCommandTest {
    ControllerStates conStates;
    DataLists masterList;
    DataLists displayList;
    StubStorage storage;
    Configuration config;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;
    String alias;

    @Before
    public void setUp() throws Exception {
        masterList = new DataLists();
        displayList = new DataLists();
        storage = new StubStorage();
        config = new Configuration();
        undoCommandHistory = new Stack<UndoableCommand>();
        redoCommandHistory = new Stack<UndoableCommand>();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = displayList;
        conStates.storage = storage;
        conStates.config = config;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;
		alias = "be";
		int keyword = 1;
		String keywordString = "buy eggs";
		
		AliasAddCommand aliasAdd = new AliasAddCommand(alias, keyword, keywordString);
		aliasAdd.execute(conStates);
    }
    
    @Test
    public void testUndo() {
		AliasDeleteCommand aliasDelete = new AliasDeleteCommand(alias);
		UIFeedback feedback = aliasDelete.execute(conStates);
		assertTrue(feedback instanceof AliasDeleteFeedback);
		assertEquals(0, conStates.config.aliases.size());
		
		feedback = aliasDelete.undo(conStates);
		assertTrue(feedback instanceof AliasAddFeedback);
		assertEquals(1, conStates.config.aliases.size());
    }

	@Test
	public void testExecute() {
		AliasDeleteCommand aliasDelete = new AliasDeleteCommand(alias);
		UIFeedback feedback = aliasDelete.execute(conStates);
		assertTrue(feedback instanceof AliasDeleteFeedback);
		assertEquals(0, conStates.config.aliases.size());
	}
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/AliasListCommandTest.java
``` java

import static org.junit.Assert.*;

import java.util.Stack;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.AliasAddCommand;
import cs2103.v15_1j.jolt.command.AliasListCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.controller.Configuration;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.parser.JoltParser;
import cs2103.v15_1j.jolt.uifeedback.AliasListFeedback;
import cs2103.v15_1j.jolt.uifeedback.UIFeedback;

public class AliasListCommandTest {
    ControllerStates conStates;
    DataLists masterList;
    DataLists displayList;
    StubStorage storage;
    Configuration config;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;
    JoltParser parser;
    String alias1;
	String keywordString1;
	String alias2;
	String keywordString2;

    @Before
    public void setUp() throws Exception {
        masterList = new DataLists();
        displayList = new DataLists();
        storage = new StubStorage();
        config = new Configuration();
        undoCommandHistory = new Stack<UndoableCommand>();
        redoCommandHistory = new Stack<UndoableCommand>();
        parser = new JoltParser();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = displayList;
        conStates.storage = storage;
        conStates.config = config;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;
        conStates.parser = parser;
        
		alias1 = "be";
		int keyword1 = 1;
		keywordString1 = "buy eggs";
		
		alias2 = "del";
		int keyword2 = 2;
		keywordString1 = "delete";
		
		AliasAddCommand aliasAdd1 = new AliasAddCommand(alias1, keyword1, keywordString1);
		AliasAddCommand aliasAdd2 = new AliasAddCommand(alias2, keyword2, keywordString2);
		aliasAdd1.execute(conStates);
		aliasAdd2.execute(conStates);
		assertEquals(2, conStates.config.aliases.size());
    }
	@Test
	public void test() {
		AliasListCommand listCommand = new AliasListCommand();
		UIFeedback feedback = listCommand.execute(conStates);
		
		assertTrue(feedback instanceof AliasListFeedback);
	}

}
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/ChangeCommandTest.java
``` java

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Stack;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.AddCommand;
import cs2103.v15_1j.jolt.command.ChangeCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.model.DeadlineTask;
import cs2103.v15_1j.jolt.model.Event;
import cs2103.v15_1j.jolt.model.FloatingTask;
import cs2103.v15_1j.jolt.model.TaskEvent;

public class ChangeCommandTest {
    ControllerStates conStates;
    DataLists masterList;
    DataLists displayList;
    StubStorage storage;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;
    TaskEvent addedTaskEvent;
    TaskEvent addedTaskEvent2;

    @Before
    public void setUp() throws Exception {
        this.masterList = new DataLists();
        this.displayList = new DataLists();
        this.storage = new StubStorage();
        this.undoCommandHistory = new Stack<UndoableCommand>();
        this.redoCommandHistory = new Stack<UndoableCommand>();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = displayList;
        conStates.storage = storage;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;

        AddCommand addCommand = new AddCommand("buy eggs", LocalDateTime.of(2016, 3, 29, 0, 0), 
        										LocalDateTime.of(2016, 4, 29, 0, 0));
        addedTaskEvent = addCommand.getTaskEvent();
        addCommand.execute(conStates);
        

        AddCommand addCommand2 = new AddCommand("buy milk");
        addedTaskEvent2 = addCommand2.getTaskEvent();
        addCommand2.execute(conStates);
        
        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
    }

    @Test
	public void testChangeName() {
		String newName = "buy ham";
		ChangeCommand changeCommand = new ChangeCommand('e', 1, newName, null,
														null, null, null);
		changeCommand.execute(conStates);
        displayList = masterList;
		Event temp = (Event) addedTaskEvent;
		assertEquals(newName, temp.getName());
	}
    
	@Test
	public void testChangeStartDate() {
		LocalDate newStartDate = LocalDateTime.of(2016, 2, 29, 0, 0).toLocalDate();
		ChangeCommand changeCommand = new ChangeCommand('e', 1, null, newStartDate,
														null, null, null);
		changeCommand.execute(conStates);
		Event temp = (Event) addedTaskEvent;
		assertEquals(newStartDate, temp.getStartDateTime().toLocalDate());
	}
	
	@Test
	public void testChangeStartTime() {
		LocalTime newStartTime = LocalDateTime.of(2016, 3, 29, 1, 0).toLocalTime();
		ChangeCommand changeCommand = new ChangeCommand('e', 1, null, null,
														newStartTime, null, null);
		changeCommand.execute(conStates);
		Event temp = (Event) addedTaskEvent;
		assertEquals(newStartTime, temp.getStartDateTime().toLocalTime());
	}

	@Test
	public void testChangeStartDateAndStartTime() {
		LocalDateTime newStartDateTime = LocalDateTime.of(2016, 2, 29, 0, 0);
		LocalDate newStartDate = newStartDateTime.toLocalDate();
		LocalTime newStartTime = newStartDateTime.toLocalTime();
		ChangeCommand changeCommand = new ChangeCommand('e', 1, null, newStartDate,
														newStartTime, null, null);
		changeCommand.execute(conStates);
		Event temp = (Event) addedTaskEvent;
		assertEquals(newStartDate, temp.getStartDateTime().toLocalDate());
		assertEquals(newStartTime, temp.getStartDateTime().toLocalTime());
	}
	
	@Test
	public void testUndoChangeStartDateAndStartTime() {
		Event temp = (Event) addedTaskEvent;
		LocalDateTime oldStartDateTime = temp.getStartDateTime();
		LocalDate oldStartDate = oldStartDateTime.toLocalDate();
		LocalTime oldStartTime = oldStartDateTime.toLocalTime();
		
		LocalDateTime newStartDateTime = LocalDateTime.of(2016, 2, 29, 0, 0);
		LocalDate newStartDate = newStartDateTime.toLocalDate();
		LocalTime newStartTime = newStartDateTime.toLocalTime();
		ChangeCommand changeCommand = new ChangeCommand('e', 1, null, newStartDate,
														newStartTime, null, null);
		changeCommand.execute(conStates);
		
		assertEquals(newStartDate, temp.getStartDateTime().toLocalDate());
		assertEquals(newStartTime, temp.getStartDateTime().toLocalTime());
		
		changeCommand.undo(conStates);
		Event currentEvent = ((Event) masterList.getTaskEvent(0,  'e'));
		assertEquals(oldStartDate, currentEvent.getStartDateTime().toLocalDate());
		assertEquals(oldStartTime, currentEvent.getStartDateTime().toLocalTime());
	}

```
###### ./src/test/java/cs2103/v15_1j/jolt/command/DeleteCommandTest.java
``` java

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.util.Stack;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.AddCommand;
import cs2103.v15_1j.jolt.command.DeleteCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.model.DeadlineTask;
import cs2103.v15_1j.jolt.model.Event;
import cs2103.v15_1j.jolt.model.FloatingTask;
import cs2103.v15_1j.jolt.uifeedback.AddFeedback;
import cs2103.v15_1j.jolt.uifeedback.DeleteFeedback;
import cs2103.v15_1j.jolt.uifeedback.FailureFeedback;
import cs2103.v15_1j.jolt.uifeedback.UIFeedback;

public class DeleteCommandTest {

    ControllerStates conStates;
    DataLists masterList = new DataLists();
    FloatingTask task1 = new FloatingTask("task 1");
    DeadlineTask task2 = new DeadlineTask("task 2", LocalDateTime.of(2016, 10, 10, 10, 10));
    Event event3 = new Event("event 3", LocalDateTime.of(2016, 10, 10, 10, 10),
            LocalDateTime.of(2016, 11, 11, 11, 11));
    StubStorage storage;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;

    @Before
    public void setUp() throws Exception {
        masterList.add(task1);
        masterList.add(task2);
        masterList.add(event3);
        this.storage = new StubStorage();
        undoCommandHistory = new Stack<UndoableCommand>();
        redoCommandHistory = new Stack<UndoableCommand>();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
        conStates.searchResultsList = new DataLists();
        conStates.storage = storage;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;
    }

    @Test
    public void testExecute() {
        DeleteCommand command = new DeleteCommand('d', 1);

        UIFeedback result = command.execute(conStates);
        assertTrue(result instanceof DeleteFeedback);
        DeleteFeedback feedback = (DeleteFeedback) result;
        assertEquals(task2, feedback.getTaskEvent());
        assertTrue(masterList.getDeadlineTasksList().isEmpty());

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);

        command = new DeleteCommand('e', 1);
        result = command.execute(conStates);
        assertTrue(result instanceof DeleteFeedback);
        feedback = (DeleteFeedback) result;
        assertEquals(event3, feedback.getTaskEvent());
        assertTrue(masterList.getEventsList().isEmpty());

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);

        command = new DeleteCommand('f', 1);
        result = command.execute(conStates);
        assertTrue(result instanceof DeleteFeedback);
        feedback = (DeleteFeedback) result;
        assertEquals(task1, feedback.getTaskEvent());
        assertTrue(masterList.getFloatingTasksList().isEmpty());

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
    }
    
    @Test
    public void testInvalidNumber() {
        DeleteCommand command = new DeleteCommand('e', -1);
        
        UIFeedback result = command.execute(conStates);
        assertTrue(result instanceof FailureFeedback);
        FailureFeedback feedback = (FailureFeedback) result;
        assertEquals("There is no item numbered e-1", feedback.getMessage());
        command = new DeleteCommand('d', 0);

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);

        result = command.execute(conStates);
        assertTrue(result instanceof FailureFeedback);
        feedback = (FailureFeedback) result;
        assertEquals("There is no item numbered d0", feedback.getMessage());
        command = new DeleteCommand('f', 100);

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);

        result = command.execute(conStates);
        assertTrue(result instanceof FailureFeedback);
        feedback = (FailureFeedback) result;
        assertEquals("There is no item numbered f100", feedback.getMessage());

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
    }
    
    @Test
    public void testStorageError() {
        assertTrue(masterList.getDeadlineTasksList().contains(task2));
        assertTrue(masterList.getDeadlineTasksList().contains(task2));
        DeleteCommand command = new DeleteCommand('d', 1);
        storage.setStorageError();

        UIFeedback result = command.execute(conStates);
        assertTrue(result instanceof FailureFeedback);
        FailureFeedback feedback = (FailureFeedback) result;
        assertEquals("Some error has occured. Please try again.",
                feedback.getMessage());
        assertTrue(masterList.getDeadlineTasksList().contains(task2));

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
    }

    @Test
    public void testUndo() {
		AddCommand addCommand = new AddCommand("buy eggs", LocalDateTime.now());
		addCommand.execute(conStates);
		AddFeedback expectedFeedback = new AddFeedback(addCommand.getTaskEvent());
		assertEquals(4, masterList.size());

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
		
		DeleteCommand deleteCommand = new DeleteCommand('d', 1);
		deleteCommand.execute(conStates);
		assertEquals(3, masterList.size());

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
		
		UIFeedback actualFeedback = deleteCommand.undo(conStates);
		assertEquals(4, masterList.size());

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
		
		assertEquals(expectedFeedback, actualFeedback);
    }
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/SaveLocationCommandTest.java
``` java

import static org.junit.Assert.*;

import java.io.File;
import java.util.Stack;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.SaveLocationCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.controller.Configuration;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.uifeedback.FailureFeedback;
import cs2103.v15_1j.jolt.uifeedback.SaveLocationFeedback;
import cs2103.v15_1j.jolt.uifeedback.UIFeedback;

public class SaveLocationCommandTest {
    ControllerStates conStates;
    DataLists masterList;
    DataLists displayList;
    StubStorage storage;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;
    Configuration config;
    String testFilePath;

    @Before
    public void setUp() throws Exception {
        masterList = new DataLists();
        displayList = new DataLists();
        storage = new StubStorage();
        undoCommandHistory = new Stack<UndoableCommand>();
        redoCommandHistory = new Stack<UndoableCommand>();
        config = new Configuration();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = displayList;
        conStates.storage = storage;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;
        conStates.config = config;
    }
    
    @After
    public void tearDown() throws Exception {
		File f = new File(testFilePath);
		f.delete();
    }
    

	@Test
	public void testExecute() {
		testFilePath = "test/save/path/save_data.json";
		SaveLocationCommand saveLocationCommand = new SaveLocationCommand(testFilePath);
		UIFeedback feedback = saveLocationCommand.execute(conStates);
		assertTrue(feedback instanceof SaveLocationFeedback);
		assertEquals(testFilePath, conStates.config.savePath);
	}
	
	@Test
	public void testStorageError() {
		((StubStorage) conStates.storage).setStorageError();
		String backup = conStates.config.savePath;
		testFilePath = "test/save/path/save_data.json";
		SaveLocationCommand saveLocationCommand = new SaveLocationCommand(testFilePath);
		UIFeedback feedback = saveLocationCommand.execute(conStates);
		assertTrue(feedback instanceof FailureFeedback);
		assertEquals(backup, conStates.config.savePath);
	}

	@Test
	public void testInvalidFilePath() {
		String backup = conStates.config.savePath;
		testFilePath = "test haha"; // Invalid file path
		SaveLocationCommand saveLocationCommand = new SaveLocationCommand(testFilePath);
		UIFeedback feedback = saveLocationCommand.execute(conStates);
		assertTrue(feedback instanceof FailureFeedback);
		assertEquals(backup, conStates.config.savePath);
	}
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/ShiftCommandTest.java
``` java

import static org.junit.Assert.*;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Stack;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.AddCommand;
import cs2103.v15_1j.jolt.command.ShiftCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.model.Event;
import cs2103.v15_1j.jolt.model.TaskEvent;
import cs2103.v15_1j.jolt.uifeedback.ShiftFeedback;
import cs2103.v15_1j.jolt.uifeedback.UIFeedback;

public class ShiftCommandTest {
    ControllerStates conStates;
    DataLists masterList;
    DataLists displayList;
    StubStorage storage;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;
    TaskEvent addedTaskEvent;

    @Before
    public void setUp() throws Exception {
        this.masterList = new DataLists();
        this.displayList = new DataLists();
        this.storage = new StubStorage();
        this.undoCommandHistory = new Stack<UndoableCommand>();
        this.redoCommandHistory = new Stack<UndoableCommand>();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = displayList;
        conStates.storage = storage;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;

        AddCommand addCommand = new AddCommand("buy eggs", LocalDateTime.of(2016, 3, 29, 0, 0), 
        										LocalDateTime.of(2016, 4, 29, 0, 0));
        addedTaskEvent = addCommand.getTaskEvent();
        addCommand.execute(conStates);

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
    }

	@Test
	public void testExecute() {
		Event temp = (Event) addedTaskEvent;
		LocalDateTime oldStartDateTime = temp.getStartDateTime();
		LocalDateTime oldEndDateTime = temp.getEndDateTime();
		long diffInSeconds = Duration.between(oldStartDateTime, oldEndDateTime).getSeconds();
		
		LocalDateTime newStartDateTime = LocalDateTime.of(2016, 2, 29, 0, 0);
		LocalDate newStartDate = newStartDateTime.toLocalDate();
		LocalTime newStartTime = newStartDateTime.toLocalTime();
		LocalDateTime expectedEndDateTime = newStartDateTime.plusSeconds(diffInSeconds);
		
		ShiftCommand command = new ShiftCommand('e', 1, newStartDate, newStartTime);
		
		UIFeedback feedback = command.execute(conStates);
		assertTrue(feedback instanceof ShiftFeedback);
		Event event = ((Event) masterList.getTaskEvent(0,  'e'));
		assertEquals(newStartDateTime, event.getStartDateTime());
		assertEquals(expectedEndDateTime, event.getEndDateTime());
	}

	@Test 
	public void testUndo() {
		Event temp = (Event) addedTaskEvent;
		LocalDateTime oldStartDateTime = temp.getStartDateTime();
		LocalDateTime oldEndDateTime = temp.getEndDateTime();
		
		LocalDateTime newStartDateTime = LocalDateTime.of(2016, 2, 29, 0, 0);
		LocalDate newStartDate = newStartDateTime.toLocalDate();
		LocalTime newStartTime = newStartDateTime.toLocalTime();
		
		ShiftCommand command = new ShiftCommand('e', 1, newStartDate, newStartTime);
		command.execute(conStates);
		
		UIFeedback feedback = command.undo(conStates);
		assertTrue(feedback instanceof ShiftFeedback);
		Event event = ((Event) masterList.getTaskEvent(0,  'e'));
		assertEquals(oldStartDateTime, event.getStartDateTime());
		assertEquals(oldEndDateTime, event.getEndDateTime());
	}
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/ShowHideOverdueCommandTest.java
``` java

import static org.junit.Assert.*;

import java.util.Stack;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.ShowHideOverdueCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.controller.Configuration;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.uifeedback.ShowHideOverdueFeedback;
import cs2103.v15_1j.jolt.uifeedback.UIFeedback;

public class ShowHideOverdueCommandTest {
    ControllerStates conStates;
    DataLists masterList;
    DataLists displayList;
    StubStorage storage;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;
    Configuration config;

    @Before
    public void setUp() throws Exception {
        masterList = new DataLists();
        displayList = new DataLists();
        storage = new StubStorage();
        undoCommandHistory = new Stack<UndoableCommand>();
        redoCommandHistory = new Stack<UndoableCommand>();
        config = new Configuration();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = displayList;
        conStates.storage = storage;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;
        conStates.config = config;
    }

	@Test
	public void testExecute() {
		boolean willShow = true;
		ShowHideOverdueCommand command = new ShowHideOverdueCommand(willShow);
		UIFeedback feedback = command.execute(conStates);
		assertTrue(feedback instanceof ShowHideOverdueFeedback);
	}
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/StubStorage.java
``` java
    @Override
    public boolean saveConfig(Configuration config) {
    	return !willCauseError;
    }
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/UndoCommandTest.java
``` java

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.util.Stack;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.command.AddCommand;
import cs2103.v15_1j.jolt.command.DeleteCommand;
import cs2103.v15_1j.jolt.command.MarkDoneCommand;
import cs2103.v15_1j.jolt.command.UndoCommand;
import cs2103.v15_1j.jolt.command.UndoableCommand;
import cs2103.v15_1j.jolt.command.UnmarkCommand;
import cs2103.v15_1j.jolt.controller.ControllerStates;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.model.TaskEvent;

public class UndoCommandTest {
    ControllerStates conStates;
    DataLists searchResultsList;
    DataLists masterList;
    StubStorage storage;
    Stack<UndoableCommand> undoCommandHistory;
    Stack<UndoableCommand> redoCommandHistory;
    UndoCommand undoCommand;
    
	@Before
	public void setUp() throws Exception {
		searchResultsList = new DataLists();
		masterList = new DataLists();
		storage = new StubStorage();
		undoCommandHistory = new Stack<UndoableCommand>();
		redoCommandHistory = new Stack<UndoableCommand>();
		undoCommand = new UndoCommand();

        conStates = new ControllerStates();
        conStates.masterList = masterList;
        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
        conStates.searchResultsList = new DataLists();
        conStates.storage = storage;
        conStates.undoCommandHistory = undoCommandHistory;
        conStates.redoCommandHistory = redoCommandHistory;
	}

	@Test
	public void testUndoAdd() {
		AddCommand addCommand = new AddCommand("buy eggs", LocalDateTime.now());
		addCommand.execute(conStates);
		assertEquals(masterList.size(), 1);
		
		undoCommand.execute(conStates);
		assertEquals(masterList.size(), 0);
	}
	
	@Test
	public void testUndoDelete() {
		AddCommand addCommand = new AddCommand("buy eggs", LocalDateTime.now());
		addCommand.execute(conStates);
		assertEquals(masterList.size(), 1);
        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
		
		DeleteCommand deleteCommand = new DeleteCommand('d', 1);
		deleteCommand.execute(conStates);
		assertEquals(masterList.size(), 0);
        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
		
		undoCommand.execute(conStates);
		assertEquals(masterList.size(), 1);
	}

	@Test
	public void testUndoMarkDone() {
		AddCommand addCommand = new AddCommand("buy eggs", LocalDateTime.now());
		TaskEvent task = addCommand.getTaskEvent();
		addCommand.execute(conStates);
		assertEquals(masterList.size(), 1);
		assertFalse(task.getCompleted());
        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
		
		MarkDoneCommand markDoneCommand = new MarkDoneCommand('d', 1);
		markDoneCommand.execute(conStates);
		assertTrue(task.getCompleted());
		undoCommand.execute(conStates);
		assertFalse(task.getCompleted());
	}
	
	@Test
	public void testUndoUnmarkDone() {
		AddCommand addCommand = new AddCommand("buy eggs", LocalDateTime.now());
		addCommand.execute(conStates);
		TaskEvent task = addCommand.getTaskEvent(); 
		assertFalse(task.getCompleted());
        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
		
		assertEquals(masterList.size(), 1);
		MarkDoneCommand markDoneCommand = new MarkDoneCommand('d', 1);
		markDoneCommand.execute(conStates);
		assertTrue(task.getCompleted());
		
		UnmarkCommand unmarkCommand = new UnmarkCommand('d', 1);
		unmarkCommand.execute(conStates);
		assertFalse(task.getCompleted());
		undoCommand.execute(conStates);
		assertTrue(task.getCompleted());
	}
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/command/UnmarkCommandTest.java
``` java
    @Test
    public void testUndo() {
		AddCommand addCommand = new AddCommand("buy eggs", LocalDateTime.now());
		addCommand.execute(conStates);
		TaskEvent addedTask = addCommand.getTaskEvent();
		MarkDoneCommand markDoneCommand = new MarkDoneCommand('d', 4);
		markDoneCommand.execute(conStates);
		MarkFeedback expectedFeedback = new MarkFeedback(addedTask);

        conStates.displayList = new DataLists();
        conStates.displayList.copy(conStates.masterList);
		
		assertEquals(4, masterList.size());
		UnmarkCommand undoMarkDoneCommand = new UnmarkCommand('d', 1);
		undoMarkDoneCommand.execute(conStates);
		UIFeedback actualFeedback = undoMarkDoneCommand.undo(conStates);
		
		assertEquals(expectedFeedback, actualFeedback);
    }
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/controller/JoltControllerTest.java
``` java
    @Test
    public void testAliasAdd() {
    	controller.execute("alias add delete del");
    	controller.execute("Prepare for German exams");
    	List<FloatingTask> masterFloatingTasksList = controller.getMasterList().getFloatingTasksList();
    	assertEquals(1, masterFloatingTasksList.size());
    	controller.states.displayList.add(masterFloatingTasksList.get(0));
    	controller.execute("del F1");
    	assertEquals(0, controller.getMasterList().getFloatingTasksList().size());
    }
    
    @Test
    public void testAliasDelete() {
    	// Test that alias was added and it works
    	controller.execute("alias add delete del");
    	controller.execute("Prepare for German exams");
    	List<FloatingTask> masterFloatingTasksList = controller.getMasterList().getFloatingTasksList();
    	assertEquals(1, masterFloatingTasksList.size());
    	controller.states.displayList.add(masterFloatingTasksList.get(0));
    	controller.execute("del f1");
    	assertEquals(0, controller.getMasterList().getFloatingTasksList().size());
    	assertEquals(1, controller.states.config.aliases.size());
    	// Test that alias was deleted and no longer works
    	controller.execute("alias delete del");
    	assertEquals(0, controller.states.config.aliases.size());
    	controller.execute("Prepare for German exams");
    	assertEquals(1, masterFloatingTasksList.size());
    	controller.states.displayList.add(masterFloatingTasksList.get(0));
    	controller.execute("del F1");
    	assertEquals(2, controller.getMasterList().getFloatingTasksList().size());
    }
}
```
###### ./src/test/java/cs2103/v15_1j/jolt/JoltSearcherTest.java
``` java

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.model.DeadlineTask;
import cs2103.v15_1j.jolt.model.Event;
import cs2103.v15_1j.jolt.model.FloatingTask;
import cs2103.v15_1j.jolt.searcher.DateTimeFilter;
import cs2103.v15_1j.jolt.searcher.Filter;
import cs2103.v15_1j.jolt.searcher.JoltSearcher;
import cs2103.v15_1j.jolt.searcher.KeywordFilter;
import cs2103.v15_1j.jolt.searcher.TimeFilter;

public class JoltSearcherTest {
	JoltSearcher JJSearcher;

	@Before
	public void setUp() throws Exception {
		JJSearcher = new JoltSearcher();
	}

	@Test
	public void testDateTimeFilter() {
		List<DeadlineTask> deadlineTasksList = new ArrayList<DeadlineTask>();
		LocalDateTime deadline1 = LocalDateTime.of(2016, 4, 6, 4, 37);
		DeadlineTask deadlineTask1 = new DeadlineTask("deadlineTask1", deadline1);
		deadlineTasksList.add(deadlineTask1);
		
		List<FloatingTask> floatingTasksList = new ArrayList<FloatingTask>();
		FloatingTask floatingTask1 = new FloatingTask("floatingTask1");
		floatingTasksList.add(floatingTask1);
		
		List<Event> eventsList = new ArrayList<Event>();
		LocalDateTime eventStart = LocalDateTime.of(2016, 4, 6, 4, 37);
		LocalDateTime eventEnd = LocalDateTime.of(2016, 4, 6, 8, 37);
		Event event1 = new Event("event1", eventStart, eventEnd);
		eventsList.add(event1);
		
		DataLists masterLists = new DataLists(deadlineTasksList, floatingTasksList, eventsList);
		
		Filter filter1 = new DateTimeFilter(LocalDateTime.of(2016, 4, 6, 3, 37),
											LocalDateTime.of(2016, 4, 6, 9, 37));
		
		List<Filter> filters = new ArrayList<Filter>();
		filters.add(filter1);
		
		DataLists result = JJSearcher.search(filters, masterLists);
		List<DeadlineTask> resultDeadlineTasksList = result.getDeadlineTasksList();
		List<FloatingTask> resultFloatingTasksList = result.getFloatingTasksList();
		List<Event> resultEventsList = result.getEventsList();
		
		assertEquals(0, resultFloatingTasksList.size());
		assertEquals(1, resultDeadlineTasksList.size());
		assertEquals(1, resultEventsList.size());
		
		assertEquals(deadlineTask1, resultDeadlineTasksList.get(0));
		assertEquals(event1, resultEventsList.get(0));
	}
	
	@Test
	public void testKeywordFilter() {
		List<DeadlineTask> deadlineTasksList = new ArrayList<DeadlineTask>();
		LocalDateTime deadline1 = LocalDateTime.now();
		// Test that a substring does not pass the filter
		DeadlineTask deadlineTask1 = new DeadlineTask("buy leggs", deadline1);
		deadlineTasksList.add(deadlineTask1);
		
		List<FloatingTask> floatingTasksList = new ArrayList<FloatingTask>();
		FloatingTask floatingTask1 = new FloatingTask("buy eggs");
		// Test that only single character keywords pass the filter
		FloatingTask floatingTask2 = new FloatingTask("Eenie meenie");
		floatingTasksList.add(floatingTask1);
		floatingTasksList.add(floatingTask2);
		
		List<Event> eventsList = new ArrayList<Event>();
		LocalDateTime eventStart = LocalDateTime.of(2016, 4, 6, 4, 37);
		LocalDateTime eventEnd = LocalDateTime.now();
		Event event1 = new Event("buying of eggs", eventStart, eventEnd);
		eventsList.add(event1);
		
		DataLists masterLists = new DataLists(deadlineTasksList, floatingTasksList, eventsList);
		
		List<String> keywords = new ArrayList<String>();
		keywords.add("Eggs"); // Test case-sensitivity
		Filter filter1 = new KeywordFilter(keywords);
		List<Filter> filters = new ArrayList<Filter>();
		filters.add(filter1);
		
		DataLists result = JJSearcher.search(filters, masterLists);
		List<DeadlineTask> resultDeadlineTasksList = result.getDeadlineTasksList();
		List<FloatingTask> resultFloatingTasksList = result.getFloatingTasksList();
		List<Event> resultEventsList = result.getEventsList();
		
		assertEquals(0, resultDeadlineTasksList.size());
		assertEquals(1, resultFloatingTasksList.size());
		assertEquals(1, resultEventsList.size());
		
		assertEquals(floatingTask1, resultFloatingTasksList.get(0));
		assertEquals(event1, resultEventsList.get(0));
	}
	
	@Test
	public void testKeywordInitialCharacterIgnoreCase() {
		List<DeadlineTask> deadlineTasksList = new ArrayList<DeadlineTask>();
		LocalDateTime deadline1 = LocalDateTime.now();
		// Test that a substring does not pass the filter
		DeadlineTask deadlineTask1 = new DeadlineTask("buy leggs", deadline1);
		deadlineTasksList.add(deadlineTask1);
		
		List<FloatingTask> floatingTasksList = new ArrayList<FloatingTask>();
		FloatingTask floatingTask1 = new FloatingTask("buy eggs");
		floatingTasksList.add(floatingTask1);
		
		List<Event> eventsList = new ArrayList<Event>();
		LocalDateTime eventStart = LocalDateTime.of(2016, 4, 6, 4, 37);
		LocalDateTime eventEnd = LocalDateTime.now();
		Event event1 = new Event("Buying of eggs", eventStart, eventEnd);
		// Test that keyword filter does not match first character of word,
		// if word is not first word of TaskEvent name
		Event event2 = new Event("Eggs of buying", eventStart, eventEnd);
		eventsList.add(event1);
		eventsList.add(event2);
		
		DataLists masterLists = new DataLists(deadlineTasksList, floatingTasksList, eventsList);
		
		List<String> keywords = new ArrayList<String>();
		keywords.add("B"); // Test case-sensitivity
		Filter filter1 = new KeywordFilter(keywords);
		List<Filter> filters = new ArrayList<Filter>();
		filters.add(filter1);
		
		DataLists result = JJSearcher.search(filters, masterLists);
		List<DeadlineTask> resultDeadlineTasksList = result.getDeadlineTasksList();
		List<FloatingTask> resultFloatingTasksList = result.getFloatingTasksList();
		List<Event> resultEventsList = result.getEventsList();
		
		assertEquals(1, resultDeadlineTasksList.size());
		assertEquals(1, resultFloatingTasksList.size());
		assertEquals(1, resultEventsList.size());
		
		assertEquals(floatingTask1, resultFloatingTasksList.get(0));
		assertEquals(event1, resultEventsList.get(0));
	}
	
	@Test
	public void testTimeFilter() {
		List<DeadlineTask> deadlineTasksList = new ArrayList<DeadlineTask>();
		LocalDateTime deadline1 = LocalDateTime.of(2016, 4, 6, 4, 37);
		DeadlineTask deadlineTask1 = new DeadlineTask("deadlineTask1", deadline1);
		deadlineTasksList.add(deadlineTask1);
		
		List<FloatingTask> floatingTasksList = new ArrayList<FloatingTask>();
		FloatingTask floatingTask1 = new FloatingTask("floatingTask1");
		floatingTasksList.add(floatingTask1);
		
		List<Event> eventsList = new ArrayList<Event>();
		LocalDateTime eventStart = LocalDateTime.of(2016, 4, 6, 4, 37);
		LocalDateTime eventEnd = LocalDateTime.of(2016, 4, 6, 8, 37);
		Event event1 = new Event("event1", eventStart, eventEnd);
		eventsList.add(event1);
		
		DataLists masterLists = new DataLists(deadlineTasksList, floatingTasksList, eventsList);
		
		Filter filter1 = new TimeFilter(LocalDateTime.of(2016, 4, 6, 3, 37).toLocalTime(),
										LocalDateTime.of(2016, 4, 6, 9, 37).toLocalTime());
		
		List<Filter> filters = new ArrayList<Filter>();
		filters.add(filter1);
		
		DataLists result = JJSearcher.search(filters, masterLists);
		List<DeadlineTask> resultDeadlineTasksList = result.getDeadlineTasksList();
		List<FloatingTask> resultFloatingTasksList = result.getFloatingTasksList();
		List<Event> resultEventsList = result.getEventsList();
		
		assertEquals(0, resultFloatingTasksList.size());
		assertEquals(1, resultDeadlineTasksList.size());
		assertEquals(1, resultEventsList.size());
		
		assertEquals(deadlineTask1, resultDeadlineTasksList.get(0));
		assertEquals(event1, resultEventsList.get(0));
	}

}
```
###### ./src/test/java/cs2103/v15_1j/jolt/JoltStorageTest.java
``` java

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jolt.controller.Configuration;
import cs2103.v15_1j.jolt.model.DataLists;
import cs2103.v15_1j.jolt.model.DeadlineTask;
import cs2103.v15_1j.jolt.model.Event;
import cs2103.v15_1j.jolt.model.FloatingTask;
import cs2103.v15_1j.jolt.storage.JoltStorage;

public class JoltStorageTest {
	private JoltStorage storage;

	@Before
	public void setUp() {
		storage = new JoltStorage();
		storage.setSaveFile("save_data_test.json");
		storage.setConfigFile("config_file_test.json");
	}
	
	@After
	public void tearDown() throws IOException {
		// Delete test JSON files after every test
		storage.getSaveFile().delete();
		storage.getConfigFile().delete();
	}
	
	/*
	 * Test that JJStorage is able to save file to disk
	 */
	@Test
	public void testSaveData() throws IOException {
		DeadlineTask task = new DeadlineTask("deadline_task", LocalDateTime.now());
		List<DeadlineTask> list = new ArrayList<DeadlineTask>();
		list.add(task);

		List<FloatingTask> floatingTasksList = new ArrayList<>();
		List<Event> eventsList = new ArrayList<>();
		DataLists dataLists = new DataLists(list, floatingTasksList, eventsList);
		
		if (storage.save(dataLists)) {
			BufferedReader bufferedReader = new BufferedReader(
			        new FileReader(storage.getSaveFile()));
			assertNotNull(bufferedReader.readLine());
			bufferedReader.close();
		}
	}
	
	/*
	 * Test that JJStorage is able to save config file
	 */
	@Test
	public void testSaveConfig() throws IOException {
		Configuration config = new Configuration();
		if (storage.saveConfig(config)) {
			BufferedReader bufferedReader = new BufferedReader(
			        new FileReader(storage.getConfigFile()));
			assertNotNull(bufferedReader.readLine());
			bufferedReader.close();
		}
	}
	
	/*
	 * Test that JJStorage is able to load config file
	 */
	@Test
	public void testLoadConfig() throws IOException {
		Configuration config = new Configuration();
		if (storage.saveConfig(config)) {
			Configuration savedConfig = storage.loadConfig();
			assertEquals(config, savedConfig);
		}
	}
	
	/*
	 * Test that JJStorage is able to successfully load data from disk
	 */
	@Test
	public void testLoadData() throws IOException {
		LocalDateTime dateTime1 = LocalDateTime.of(2016, 3, 6, 4, 37);
		LocalDateTime dateTime2 = LocalDateTime.of(2015, 3, 6, 4, 37);
		DeadlineTask deadlineTask1 = new DeadlineTask("task1", dateTime1);
		DeadlineTask deadlineTask2 = new DeadlineTask("task2", dateTime2);
		List<DeadlineTask> list = new ArrayList<DeadlineTask>();
		list.add(deadlineTask1);
		list.add(deadlineTask2);
		
		List<FloatingTask> floatingTasksList = new ArrayList<>();
		List<Event> eventsList = new ArrayList<>();
		DataLists result = new DataLists(list, floatingTasksList, eventsList);
		
		if (storage.save(result)) {
			DataLists savedDataLists = storage.load();
			List<DeadlineTask> savedDeadlineTasksList = savedDataLists.getDeadlineTasksList();
			assertEquals(2, savedDeadlineTasksList.size());
			
			DeadlineTask savedDeadlineTask1 = (DeadlineTask) savedDeadlineTasksList.get(0);
			DeadlineTask savedDeadlineTask2 = (DeadlineTask) savedDeadlineTasksList.get(1);
			
			// Assert that tasks returned are instances of Task
			assertEquals(true, savedDeadlineTask1 instanceof DeadlineTask);
			assertEquals(true, savedDeadlineTask2 instanceof DeadlineTask);

			// Assert that loaded tasks are identical to the tasks that were saved
			assertEquals("task1", savedDeadlineTask1.getName());
			assertEquals(dateTime1, savedDeadlineTask1.getDateTime());

			assertEquals("task2", savedDeadlineTask2.getName());
			assertEquals(dateTime2, savedDeadlineTask2.getDateTime());
		} else {
			fail("JJStorage was unable to save file.");
		}
	}
}
```
